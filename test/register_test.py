import unittest
import os
from appium import webdriver
from appium.webdriver.common.appiumby import AppiumBy
from appium.options.android import UiAutomator2Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException
from openpyxl import Workbook, load_workbook
import subprocess
import time

# Test data
TEST_DATA = {
    "TC_REGISTER_01": {
        "description": "Verify register with empty username",
        "username": "",
        "email": "test@example.com",
        "password": "Pass@123",
        "confirm_password": "Pass@123",
        "expected": "error:Username kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng!"
    },
    "TC_REGISTER_02": {
        "description": "Verify register with empty email",
        "username": "Test User",
        "email": "",
        "password": "Pass@123",
        "confirm_password": "Pass@123",
        "expected": "error:Email kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng!"
    },
    "TC_REGISTER_03": {
        "description": "Verify register with empty password",
        "username": "Test User",
        "email": "test@example.com",
        "password": "",
        "confirm_password": "Pass@123",
        "expected": "error:M·∫≠t kh·∫©u kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng!"
    },
    "TC_REGISTER_04": {
        "description": "Verify register with empty confirm password",
        "username": "Test User",
        "email": "test@example.com",
        "password": "Pass@123",
        "confirm_password": "",
        "expected": "error:Nh·∫≠p l·∫°i m·∫≠t kh·∫©u kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng!"
    },
    "TC_REGISTER_05": {
        "description": "Verify register with invalid email format",
        "username": "Test User",
        "email": "invalid_email",
        "password": "Pass@123",
        "confirm_password": "Pass@123",
        "expected": "error:Email kh√¥ng h·ª£p l·ªá!"
    },
    "TC_REGISTER_06": {
        "description": "Verify register with password less than 8 characters",
        "username": "Test User",
        "email": "test@example.com",
        "password": "Pass@12",
        "confirm_password": "Pass@12",
        "expected": "error:M·∫≠t kh·∫©u √≠t nh·∫•t 8  k√Ω t·ª±, ch·ª©a 1 s·ªë v√† 1 ch·ªØ in hoa!"
    },
    "TC_REGISTER_07": {
        "description": "Verify register with password missing uppercase letter",
        "username": "Test User",
        "email": "test@example.com",
        "password": "pass@123",
        "confirm_password": "pass@123",
        "expected": "error:M·∫≠t kh·∫©u √≠t nh·∫•t 8 k√Ω t·ª±, ch·ª©a 1 s·ªë v√† 1 ch·ªØ in hoa!"
    },
    "TC_REGISTER_08": {
        "description": "Verify register with password missing number",
        "username": "Test User",
        "email": "test@example.com",
        "password": "Pass@abc",
        "confirm_password": "Pass@abc",
        "expected": "error:M·∫≠t kh·∫©u √≠t nh·∫•t 8 k√Ω t·ª±, ch·ª©a 1 s·ªë v√† 1 ch·ªØ in hoa!"
    },
    "TC_REGISTER_09": {
        "description": "Verify register with mismatched passwords",
        "username": "Test User",
        "email": "test@example.com",
        "password": "Pass@123",
        "confirm_password": "Pass@124",
        "expected": "error:M·∫≠t kh·∫©u kh√¥ng kh·ªõp!"
    },
    "TC_REGISTER_10": {
        "description": "Verify register with existing email",
        "username": "Test User",
        "email": "existing@example.com",
        "password": "Pass@123",
        "confirm_password": "Pass@123",
        "expected": "error:User already exists!"
    },
    "TC_REGISTER_11": {
        "description": "Verify register with SQL injection input",
        "username": "' OR '1'='1",
        "email": "' OR '1'='1@example.com",
        "password": "Pass@123",
        "confirm_password": "Pass@123",
        "expected": "error:Email kh√¥ng h·ª£p l·ªá!"
    },
    "TC_REGISTER_12": {
        "description": "Verify register with valid data and successful navigation to login screen",
        "username": "Levantuan",
        "email": "levantuan123@gmail.com",
        "password": "Levantuan123@",
        "confirm_password": "Levantuan123@",
        "expected": "login_screen"
    }
}

# ƒê∆∞·ªùng d·∫´n file Excel
output_dir = "output"
file_path = os.path.join(output_dir, "test_results_register.xlsx")
results = []

# T·∫°o th∆∞ m·ª•c output n·∫øu ch∆∞a c√≥
if not os.path.exists(output_dir):
    os.makedirs(output_dir)

# N·∫øu file kh√¥ng t·ªìn t·∫°i -> t·∫°o m·ªõi
if not os.path.exists(file_path):
    wb = Workbook()
    ws = wb.active
    ws.append(["Test Case", "Description", "Result", "Status", "Note"])
    wb.save(file_path)

class TestRegisterAppium(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        """Kh·ªüi t·∫°o k·∫øt n·ªëi Appium"""
        print("üîó Connecting to Appium...")
        
        # Ki·ªÉm tra thi·∫øt b·ªã Android
        try:
            devices = subprocess.check_output("adb devices", shell=True).decode()
            if "b9fff218" not in devices:
                raise Exception("Emulator-5554 not found. Please start the emulator.")
        except subprocess.CalledProcessError:
            raise Exception("Error running adb. Ensure Android SDK is installed and adb is in PATH.")

        # C·∫•u h√¨nh Appium
        options = UiAutomator2Options()
        options.platform_name = "Android"
        options.device_name = "MyAndroidDevice"
        options.udid = "b9fff218"
        options.app_package = "com.example.flutter_shop"
        options.app_activity = "com.example.flutter_shop.MainActivity"
        options.automation_name = "UiAutomator2"
        options.no_reset = True  # Kh√¥ng reset ·ª©ng d·ª•ng ƒë·ªÉ gi·ªØ tr·∫°ng th√°i

        # Th·ª≠ k·∫øt n·ªëi v·ªõi retry
        max_attempts = 3
        for attempt in range(max_attempts):
            try:
                cls.driver = webdriver.Remote("http://localhost:4723", options=options)
                cls.wait = WebDriverWait(cls.driver, 60)
                print("‚úÖ Connected successfully!")
                break
            except Exception as e:
                print(f"‚ö†Ô∏è Appium connection error (attempt {attempt + 1}/{max_attempts}): {str(e)}")
                if attempt == max_attempts - 1:
                    raise Exception("Failed to connect to Appium after multiple attempts.")
                time.sleep(2)

        # ƒêi·ªÅu h∆∞·ªõng t·ªõi m√†n h√¨nh ƒëƒÉng k√Ω
        cls.navigate_to_register_screen()

    @classmethod
    def navigate_to_register_screen(cls):
        """ƒêi·ªÅu h∆∞·ªõng t·ªõi m√†n h√¨nh ƒëƒÉng k√Ω"""
        try:
            # Click v√†o Create an account
            create_account_button = cls.wait.until(EC.element_to_be_clickable(
                (AppiumBy.XPATH, "//android.widget.Button[@content-desc='Create an account']")
            ))
            create_account_button.click()
            print("üñ±Ô∏è Clicked Create an account")
            time.sleep(2)

            # Ki·ªÉm tra xem ƒë√£ ·ªü m√†n h√¨nh ƒëƒÉng k√Ω ch∆∞a (gi·ªØ nguy√™n logic c≈© n·∫øu c·∫ßn)
            try:
                login_button = cls.wait.until(EC.element_to_be_clickable(
                    (AppiumBy.XPATH, "//android.widget.Button[@text='Already have an account? Login']")
                ))
                login_button.click()
                print("üñ±Ô∏è Clicked to navigate to register screen")
                time.sleep(2)
            except TimeoutException:
                print("‚ö†Ô∏è Could not find button to navigate to register screen")
        except TimeoutException as e:
            print(f"‚ö†Ô∏è Navigation error: {str(e)}")

    @classmethod
    def tearDownClass(cls):
        """ƒê√≥ng k·∫øt n·ªëi Appium v√† l∆∞u k·∫øt qu·∫£"""
        cls.driver.quit()
        print("üî¥ Disconnected!")
        wb = load_workbook(file_path)
        ws = wb.active
        for result in results:
            ws.append(result)
        wb.save(file_path)
        print(f"üìù Results saved to {file_path}")

    def clear_form(self):
        """X√≥a d·ªØ li·ªáu trong form ƒëƒÉng k√Ω"""
        try:
            fields = [
                "//android.widget.EditText[@index='1']",  # Username
                "//android.widget.EditText[@index='2']",  # Email
                "//android.widget.EditText[@index='3']",  # Password
                "//android.widget.EditText[@index='4']"   # Confirm Password
            ]
            for xpath in fields:
                field = self.wait.until(EC.visibility_of_element_located((AppiumBy.XPATH, xpath)))
                field.click()
                field.clear()
            print("üßπ Form cleared")
        except TimeoutException as e:
            print(f"‚ö†Ô∏è Could not clear form: {str(e)}")

    def register(self, username, email, password, confirm_password, expected_error=None):
        """H√†m th·ª±c hi·ªán ƒëƒÉng k√Ω"""
        try:
            print(f"üîç Registering with Username: {username} / Email: {email} / Password: {password} / Confirm Password: {confirm_password}")
            # Tr∆∞·ªùng Username
            username_field = self.wait.until(EC.visibility_of_element_located(
                (AppiumBy.XPATH, "//android.widget.EditText[@index='1']")
            ))
            username_field.click()
            username_field.clear()
            username_field.send_keys(username)

            # Tr∆∞·ªùng Email
            email_field = self.wait.until(EC.visibility_of_element_located(
                (AppiumBy.XPATH, "//android.widget.EditText[@index='2']")
            ))
            email_field.click()
            email_field.clear()
            email_field.send_keys(email)

            # Tr∆∞·ªùng Password
            pass_field = self.wait.until(EC.visibility_of_element_located(
                (AppiumBy.XPATH, "//android.widget.EditText[@index='3']")
            ))
            pass_field.click()
            pass_field.clear()
            pass_field.send_keys(password)

            # Tr∆∞·ªùng Confirm Password
            confirm_pass_field = self.wait.until(EC.visibility_of_element_located(
                (AppiumBy.XPATH, "//android.widget.EditText[@index='4']")
            ))
            confirm_pass_field.click()
            confirm_pass_field.clear()
            confirm_pass_field.send_keys(confirm_password)
            time.sleep(2)

            # Nh·∫•n n√∫t Register
            register_button = self.wait.until(EC.element_to_be_clickable(
                (AppiumBy.XPATH, "//android.widget.Button[@content-desc='Register']")
            ))
            register_button.click()
            print("üñ±Ô∏è Clicked Register button!")

            # Ch·ªù ng·∫Øn h∆°n ƒë·ªÉ ki·ªÉm tra th√¥ng b√°o l·ªói ho·∫∑c chuy·ªÉn h∆∞·ªõng
            time.sleep(3)

            # N·∫øu c√≥ l·ªói mong ƒë·ª£i, ki·ªÉm tra th√¥ng b√°o l·ªói ngay sau khi nh·∫•n Register
            if expected_error and expected_error != "login_screen":
                error_msg = expected_error.split("error:")[1]
                if self.is_error_message_displayed(error_msg):
                    print("‚ùå ƒêƒÉng k√Ω kh√¥ng th√†nh c√¥ng!")
                    return None
                else:
                    print("‚ùå ƒêƒÉng k√Ω kh√¥ng th√†nh c√¥ng! Kh√¥ng t√¨m th·∫•y th√¥ng b√°o l·ªói mong ƒë·ª£i.")
                    return "Error message not displayed"

            # Ki·ªÉm tra n·∫øu chuy·ªÉn h∆∞·ªõng th√†nh c√¥ng t·ªõi m√†n h√¨nh ƒëƒÉng nh·∫≠p
            if self.is_login_screen():
                if expected_error == "login_screen":
                    print("‚úÖ ƒêƒÉng k√Ω th√†nh c√¥ng! Chuy·ªÉn h∆∞·ªõng ƒë·∫øn m√†n h√¨nh ƒëƒÉng nh·∫≠p")
                    return None
                else:
                    print("‚ùå ƒêƒÉng k√Ω kh√¥ng th√†nh c√¥ng! Chuy·ªÉn h∆∞·ªõng sai ƒë·∫øn m√†n h√¨nh ƒëƒÉng nh·∫≠p")
                    return "Unexpected navigation to login screen"
            else:
                print("‚ùå ƒêƒÉng k√Ω kh√¥ng th√†nh c√¥ng! Kh√¥ng chuy·ªÉn h∆∞·ªõng ƒë·∫øn m√†n h√¨nh ƒëƒÉng nh·∫≠p")
                return "Failed to redirect to login screen after registration"

        except TimeoutException as e:
            print("‚ùå ƒêƒÉng k√Ω kh√¥ng th√†nh c√¥ng!")
            return f"Error: Element not found - {str(e)}"
        except Exception as e:
            print("‚ùå ƒêƒÉng k√Ω kh√¥ng th√†nh c√¥ng!")
            return f"Unknown error: {str(e)}"

    def is_login_screen(self):
        """Ki·ªÉm tra xem c√≥ ƒëang ·ªü m√†n h√¨nh ƒëƒÉng nh·∫≠p"""
        try:
            self.wait.until(EC.visibility_of_element_located(
                (AppiumBy.XPATH, "//android.widget.EditText[@index='1']")  # Tr∆∞·ªùng email c·ªßa login
            ))
            print("")
            return True
        except TimeoutException:
            print("‚ùì Not on login screen")
            return False

    def is_error_message_displayed(self, expected_message):
        """Ki·ªÉm tra th√¥ng b√°o l·ªói v·ªõi th·ªùi gian ch·ªù ng·∫Øn h∆°n"""
        try:
            # S·ª≠ d·ª•ng WebDriverWait v·ªõi th·ªùi gian ch·ªù 3 gi√¢y
            WebDriverWait(self.driver, 5).until(EC.visibility_of_element_located(
                (AppiumBy.XPATH, f"//android.widget.TextView[@text='{expected_message}']")
            ))
            print(f"‚ö†Ô∏è Error message found: '{expected_message}'")
            return True
        except TimeoutException:
            print(f"‚ùå Error message not found: '{expected_message}'")
            return False

    def navigate_back_to_register(self):
        """ƒêi·ªÅu h∆∞·ªõng tr·ªü l·∫°i m√†n h√¨nh ƒëƒÉng k√Ω sau m·ªói test"""
        if self.is_login_screen():
            try:
                login_button = self.wait.until(EC.element_to_be_clickable(
                    (AppiumBy.XPATH, "//android.widget.Button[@text='Already have an account? Login']")
                ))
                login_button.click()
                print("üñ±Ô∏è Navigated back to register screen")
                time.sleep(2)
            except TimeoutException:
                print("")
                self.navigate_to_register_screen()

    def test_register_sequential(self):
        """Ch·∫°y tu·∫ßn t·ª± t·∫•t c·∫£ c√°c test case cho ƒë·∫øn khi ƒëƒÉng k√Ω th√†nh c√¥ng"""
        for test_id in TEST_DATA.keys():
            data = TEST_DATA[test_id]
            print(f"\nüìã Running test {test_id}: {data['description']}")
            
            # G·ªçi h√†m register v·ªõi th√¥ng b√°o l·ªói mong ƒë·ª£i
            error = self.register(
                data["username"],
                data["email"],
                data["password"],
                data["confirm_password"],
                data["expected"]
            )
            expected = data["expected"]
            
            if expected == "login_screen":
                # Tr∆∞·ªùng h·ª£p t√≠ch c·ª±c: Mong ƒë·ª£i ƒëƒÉng k√Ω th√†nh c√¥ng v√† chuy·ªÉn h∆∞·ªõng
                if error is None and self.is_login_screen():
                    result = True
                    status = "Pass"
                    note = "Successfully registered and redirected to login screen"
                    print("‚úÖ Test PASS: Registration successful")
                else:
                    result = False
                    status = "Fail"
                    note = error if error else "Failed to reach login screen"
                    print(f"‚ùå Test FAIL: {note}")
            else:
                # Tr∆∞·ªùng h·ª£p ti√™u c·ª±c: K·∫øt qu·∫£ d·ª±a tr√™n ki·ªÉm tra trong h√†m register
                error_msg = expected.split("error:")[1]
                result = error is None  # N·∫øu kh√¥ng c√≥ l·ªói tr·∫£ v·ªÅ t·ª´ register, t·ª©c l√† t√¨m th·∫•y th√¥ng b√°o l·ªói
                status = "Pass" if result else "Fail"
                note = f"Expected error shown: '{error_msg}'" if result else f"Error message not displayed: '{error_msg}'"
                print(f"{'‚úÖ Test PASS' if result else '‚ùå Test FAIL'}: {note}")

            results.append([test_id, data["description"], result, status, note])
            print(f"üìä Recorded result for {test_id}: {status}")

            # N·∫øu ƒëƒÉng k√Ω th√†nh c√¥ng (TC_REGISTER_12), d·ª´ng l·∫°i
            if expected == "login_screen" and status == "Pass":
                break

            # X√≥a form v√† ti·∫øp t·ª•c test case ti·∫øp theo
            self.clear_form()
            # ƒêi·ªÅu h∆∞·ªõng l·∫°i m√†n h√¨nh ƒëƒÉng k√Ω n·∫øu c·∫ßn
            if not self.is_login_screen():
                self.navigate_to_register_screen()

if __name__ == "__main__":
    unittest.main()